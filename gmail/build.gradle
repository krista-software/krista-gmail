plugins {
    id 'java'
    id "com.github.node-gradle.node" version "3.1.0"
    id 'maven-publish'
    id 'jacoco'
    id("org.sonarqube") version "6.3.1.5724"

}

apply plugin: 'java-library'

group = 'app.kristasoft.extensions.essentials.collaboration'

sonar {
    properties {
        property('sonar.projectName', 'SonarScanner for Krista Global Catalog (StaticAuthentication with Jacoco code coverage)')
        property("sonar.projectKey", "sonar-scanner-StaticAuthentication")
        property("sonar.sources", "src/main/java")
        property("sonar.tests", "src/test/java")
        property("sonar.java.binaries", "build/classes/java/main")
        property("sonar.java.test.binaries", "build/classes/java/test")
        property("sonar.coverage.jacoco.xmlReportPaths", "build/reports/jacoco/test/jacocoTestReport.xml")
        property("sonar.junit.reportPaths", "build/test-results/test")
    }
}
tasks.test {
    // Generate coverage report after tests run
    finalizedBy(tasks.jacocoTestReport)
}
jacoco {
    toolVersion = "0.8.11"
}

jacocoTestReport {
    dependsOn test
    reports {
        xml.required = true
        html.required = true
        csv.required = false
    }
    afterEvaluate {
        classDirectories.setFrom(files(classDirectories.files.collect {
            fileTree(dir: it, exclude: [
                    '**/api/**',
                    '**/GmailApplication.class'
            ])
        }))
    }
}

test {
    finalizedBy jacocoTestReport
}
// Ensure Sonar runs only after JaCoCo report generation
tasks.named("sonar") {
    dependsOn(tasks.jacocoTestReport)
}
def computedBaseName = "gmail-extension"
def computedVersion = "local"
def releasePropsFile = file('release.properties')
if (releasePropsFile.exists()) {
    def props = new Properties()
    releasePropsFile.withInputStream { stream -> props.load(stream) }
    // Remove whitespace for base name, but allow dashes/underscores
    computedBaseName = (props['extension.name'] ?: "Gmail Extension").replaceAll(/\s+/, "")
    computedVersion = props['extension.version'] ?: "local"
}
version = computedVersion

if (rootProject.file('builder.txt').canRead()) {
    ext.builder = rootProject.file('builder.txt').text.trim()
} else {
    ext.builder = "0"
}

task updateVersion {
    doFirst {
        project.ext.newbuilder = Integer.parseInt(project.ext.builder) + 1
        print "Building extension version: " + version.toString() + "-" + project.ext.newbuilder
        rootProject.file('builder.txt').text = project.ext.newbuilder
        System.clearProperty("extensionVersion")
        System.setProperty("extensionVersion", version.toString() + "-" + project.ext.newbuilder)
    }
}

System.setProperty("extensionVersion", version.toString())

sourceCompatibility = '21'
targetCompatibility = '21'

repositories {
    maven {
        url "https://packages.cicd.in.antbrains.com/artifactory/libs-release"
    }
    mavenCentral()
    mavenLocal()
}

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8'
    options.compilerArgs << '-Xlint:all,-serial'
}

tasks.register('compile') {
    dependsOn compileJava
}

configurations {
    implementation {
        canBeConsumed = false
        canBeResolved = true
    }
}

test {
    useJUnitPlatform()

    // Add these settings to help diagnose test issues
    testLogging {
        events "passed", "skipped", "failed"
        exceptionFormat "full"
    }

    // Enable experimental support for Java 23 in Byte Buddy
    jvmArgs '-Dnet.bytebuddy.experimental=true'

    // Use a different mocking strategy
    systemProperty 'mockito.mock.maker', 'subclass'

    // Increase memory if needed
    maxHeapSize = "1G"
}

dependencies {

    annotationProcessor 'app.krista:extension-impl-anno-processors:1.0.120' // used to generate the extension.json
    compileOnly 'app.krista:krista-apis:1.0.120' // defines the Krista Service APIs
    compileOnly 'org.glassfish.hk2:hk2-api:2.6.1' // used to define scope of objects
    implementation 'com.github.scribejava:scribejava-apis:8.3.3'
    implementation 'javax.mail:mail:1.4.7'
    implementation 'com.google.apis:google-api-services-gmail:v1-rev20231218-2.0.0'
    implementation 'org.glassfish.jersey.media:jersey-media-multipart:2.35'
    implementation 'org.jsoup:jsoup:1.15.1'
    implementation 'app.krista:krista-apis:1.0.98'
    implementation 'org.glassfish.hk2:hk2-api:3.0.3'
    implementation group: 'commons-validator', name: 'commons-validator', version: '1.7'

    // Test dependencies
    testImplementation 'org.junit.jupiter:junit-jupiter:5.10.0'
    testImplementation 'org.mockito:mockito-core:5.5.0'
    testImplementation 'org.mockito:mockito-junit-jupiter:5.5.0'
    testImplementation 'org.assertj:assertj-core:3.24.2'
    testImplementation 'app.krista:krista-apis:1.0.118' // needed for ExtensionResponse in tests

}

tasks.register('createSourceDir', Exec) {
    dependsOn processResources
    commandLine "mkdir", "-p", "$projectDir/build/classes/java/main/META-INF/project"
}

tasks.register('copyGradleFile', Exec) {
    dependsOn createSourceDir
    commandLine "cp", "$projectDir/build.gradle", "$projectDir/build/classes/java/main/META-INF/project/build.gradle"
}

tasks.register('includeSources', Exec) {
    dependsOn copyGradleFile
    commandLine "cp", "-r", "$projectDir/src", "$projectDir/build/classes/java/main/META-INF/project/src"
}

tasks.register('candidate', Exec) {
    commandLine "env",
            "DOCKER_UPLOAD_REPO=" + rootProject.properties['DOCKER_UPLOAD_REPO'],
            "MAVEN_URL=" + System.properties['MAVEN_URL'],
            "MAVEN_UPLOAD_URL=" + rootProject.properties['MAVEN_UPLOAD_URL'],
            "MAVEN_USERNAME=" + rootProject.properties['MAVEN_USERNAME'],
            "MAVEN_PASSWORD=" + rootProject.properties['MAVEN_PASSWORD'],
            "bash", "candidate.sh"
    standardOutput = new ByteArrayOutputStream()
    ext.output = {
        return standardOutput.toString()
    }
}

tasks.register('release', Exec) {
    commandLine "env",
            "DOCKER_UPLOAD_REPO=" + rootProject.properties['DOCKER_UPLOAD_REPO'],
            "MAVEN_URL=" + System.properties['MAVEN_URL'],
            "MAVEN_UPLOAD_URL=" + rootProject.properties['MAVEN_UPLOAD_URL'],
            "MAVEN_USERNAME=" + rootProject.properties['MAVEN_USERNAME'],
            "MAVEN_PASSWORD=" + rootProject.properties['MAVEN_PASSWORD'],
            "bash", "release.sh"
    standardOutput = new ByteArrayOutputStream()
    ext.output = {
        return standardOutput.toString()
    }
}

tasks.register('filepermission', Exec) {
    commandLine('chmod', '-R', '755', "${project.projectDir}/src/main/ui/gmailoauth")
}

import java.util.regex.Pattern

abstract class GenerateReleasePropertiesTask extends DefaultTask {
    @TaskAction
    def generateProperties() {
        def extensionFilePath = 'src/main/java/app/krista/extensions/essentials/collaboration/gmail/GmailExtension.java'
        def areaFilePath = 'src/main/java/app/krista/extensions/essentials/collaboration/gmail/catalog/MessagingArea.java'
        def extensionFile = project.file(extensionFilePath)
        def areaFile = project.file(areaFilePath)
        if (!extensionFile.exists()) {
            throw new GradleException("Extension file not found: ${extensionFilePath}")
        }
        if (!areaFile.exists()) {
            throw new GradleException("Area file not found: ${areaFilePath}")
        }
        def properties = new Properties()
        // Pre-compile the regex pattern for better performance
        def keyValuePattern = Pattern.compile(/(\w+)\s*=\s*"([^"]+)"/)
        // Extract Extension annotation information
        extractAnnotationInfo(extensionFile, "@Extension", keyValuePattern) { key, value ->
            if (key == "name") {
                properties.setProperty("extension.name", value)
                logger.lifecycle("Found extension name: ${value}")
            } else if (key == "version") {
                properties.setProperty("extension.version", value)
                logger.lifecycle("Found extension version: ${value}")
            }
        }
        // Extract Domain annotation information
        extractAnnotationInfo(areaFile, "@Domain", keyValuePattern) { key, value ->
            if (key == "name") {
                properties.setProperty("domain.name", value)
                logger.lifecycle("Found domain name: ${value}")
            } else if (key == "ecosystemName") {
                properties.setProperty("ecosystem.name", value)
                logger.lifecycle("Found ecosystem name: ${value}")
            }
        }
        if (!properties.getProperty('extension.version')) {
            throw new GradleException("Could not find extension version in ${extensionFilePath}")
        }
        if (!properties.getProperty('domain.name') || !properties.getProperty('ecosystem.name')) {
            throw new GradleException("Could not find domain name or ecosystem name in ${areaFilePath}")
        }
        def releasePropertiesFile = project.file('release.properties')
        def content = properties.collect { key, value -> "${key}=${value}" }.join('\n')
        releasePropertiesFile.text = content + '\n'
        logger.lifecycle("Generated release.properties with content:\n${content}")
    }
    /**
     * Extracts annotation information from a file
     * @param file The file to extract from
     * @param annotationName The annotation name to look for
     * @param keyValuePattern The regex pattern to extract key-value pairs
     * @param processProperty Closure to process each property
     */
    private static void extractAnnotationInfo(File file, String annotationName, Pattern keyValuePattern, Closure processProperty) {
        StringBuilder annotationText = new StringBuilder()
        boolean inAnnotation = false
        file.eachLine { line ->
            line = line.trim()
            if (line.contains(annotationName)) {
                inAnnotation = true
            }
            if (inAnnotation) {
                annotationText.append(line)
                if (line.contains(")")) {
                    inAnnotation = false
                    def matcher = keyValuePattern.matcher(annotationText.toString())
                    while (matcher.find()) {
                        def key = matcher.group(1)
                        def value = matcher.group(2)
                        processProperty.call(key, value)
                    }
                }
            }
        }
    }
}

tasks.register('generateReleaseProperties', GenerateReleasePropertiesTask) {
    group = 'build'
    description = 'Generates release.properties file with extension version and domain information'
}

jar {
    dependsOn tasks.named("generateReleaseProperties")

    // Without this dependency, the jar task may use the fallback "local" value if the file is not available during configuration.
    archiveBaseName.set(computedBaseName)

    doFirst {
        // Wait for half a second to ensure generateReleaseProperties file is fully generated
        println "Waiting half second for generateReleaseProperties to complete..."
        Thread.sleep(500)
        println "Wait complete, proceeding with jar creation..."

        // Re-read the release.properties file at execution time to get the correct values
        def jarReleasePropsFile = file('release.properties')
        if (jarReleasePropsFile.exists()) {
            def props = new Properties()
            jarReleasePropsFile.withInputStream { stream -> props.load(stream) }
            // Use extension.name if available, otherwise fall back to default
            def actualBaseName = (props['extension.name'] ?: "Gmail Extension").replaceAll(/\s+/, "")
            def actualVersion = props['extension.version'] ?: "local"

            println "Using jar name from release.properties: ${actualBaseName}-${actualVersion}.jar"

            // Update the archive base name and version at execution time
            archiveBaseName.set(actualBaseName)
            archiveVersion.set(actualVersion)
        } else {
            println "release.properties not found, using fallback values"
        }
    }

    manifest {}
    from {
        configurations.runtimeClasspath.collect {
            it.isDirectory() ? it : zipTree(it)
        }
    }
    exclude 'META-INF/*.RSA', 'META-INF/*.SF', 'META-INF/*.DSA'
    duplicatesStrategy = "exclude"
}

tasks.withType(Test).configureEach {
    doFirst {
        def byteBuddyAgent = configurations.testRuntimeClasspath.find { it.name.contains('byte-buddy-agent') }
        if (byteBuddyAgent) {
            jvmArgs "-javaagent:${byteBuddyAgent}"
        }
    }
}

// Add a task to create the mockito-extensions directory and file
tasks.register('createMockitoExtensions') {
    doLast {
        def mockitoDir = file("${projectDir}/src/test/resources/mockito-extensions")
        mockitoDir.mkdirs()
        def mockMakerFile = file("${mockitoDir}/org.mockito.plugins.MockMaker")
        mockMakerFile.text = 'mock-maker-inline\n'
        println "Created mockito-extensions directory and MockMaker file"
    }
}

// Make sure the test task depends on createMockitoExtensions
tasks.named('test') {
    dependsOn tasks.named('createMockitoExtensions')
}

